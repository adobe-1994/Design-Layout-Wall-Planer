<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ArtFrame/22 : Design Layout</title>
  <!-- Font Awesome cho icon -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      --color-bg-base: #0f172a;      /* Nền tối nhất */
      --color-bg-elevated: #1e293b;  /* Nền panel */
      --color-bg-surface: #334155;   /* Nền input/button phụ */
      --color-text-primary: #f1f5f9;
      --color-text-secondary: #94a3b8;
      --color-primary: #38bdf8;      /* Xanh dương nhạt */
      --color-primary-hover: #0ea5e9;
      --color-border: rgba(148, 163, 184, 0.2);
      --color-success: #22c55e;
      --color-error: #ef4444;
      --color-warning: #f59e0b;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: var(--color-bg-base);
      color: var(--color-text-primary);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden; /* Chống cuộn toàn trang */
    }

    /* =========================================
       CANVAS AREA (Nửa trên)
       ========================================= */
    .canvas-container {
      flex: 1; /* Chiếm phần không gian còn lại (khoảng 50-60%) */
      position: relative;
      background: #0f172a;
      overflow: hidden;
      touch-action: none; /* Rất quan trọng cho mobile để kéo thả */
      z-index: 1;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Floating Tools (Nút nổi góc phải) */
    .floating-tools {
      position: absolute;
      top: 15px;
      right: 15px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 10;
    }

    .tool-btn {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      background: rgba(51, 65, 85, 0.8);
      backdrop-filter: blur(4px);
      border: 1px solid rgba(255,255,255,0.1);
      color: var(--color-text-primary);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      cursor: pointer;
      transition: 0.2s;
    }
    .tool-btn:active { background: var(--color-primary); color: #0f172a; }
    .tool-btn:disabled { opacity: 0.3; pointer-events: none; }

    #zoom-indicator {
      position: absolute;
      bottom: 15px; left: 15px;
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 5px 10px; border-radius: 6px;
      font-size: 12px; pointer-events: none;
      opacity: 0; transition: opacity 0.3s;
    }

    /* =========================================
       BOTTOM CONTROLS (Nửa dưới)
       ========================================= */
    .controls-area {
      height: 50vh; /* Cố định chiều cao nửa dưới */
      display: flex;
      flex-direction: column;
      background: var(--color-bg-elevated);
      border-top: 1px solid var(--color-border);
      z-index: 10;
    }

    /* Tabs Navigation */
    .tabs-nav {
      display: flex;
      background: var(--color-bg-base);
      border-bottom: 1px solid var(--color-border);
    }

    .tab-btn {
      flex: 1;
      background: none;
      border: none;
      padding: 12px 0;
      color: var(--color-text-secondary);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      transition: all 0.2s;
    }

    .tab-btn i { font-size: 18px; }
    .tab-btn.active {
      color: var(--color-primary);
      border-bottom-color: var(--color-primary);
      background: rgba(56, 189, 248, 0.05);
    }

    /* Panels Container */
    .panels-container {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      background: var(--color-bg-base);
    }

    .tab-content { display: none; }
    .tab-content.active { display: block; animation: fadeIn 0.3s ease; }

    @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

    /* =========================================
       UI ELEMENTS (Inputs, Buttons, Panels)
       ========================================= */
    .panel-card {
      background: var(--color-bg-elevated);
      border: 1px solid var(--color-border);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }

    .section-title {
      font-size: 13px;
      text-transform: uppercase;
      font-weight: 600;
      margin-bottom: 16px;
      color: var(--color-text-secondary);
      letter-spacing: 0.5px;
    }

    .form-group { margin-bottom: 14px; }
    .form-label { display: block; font-size: 12px; color: var(--color-text-secondary); margin-bottom: 8px; }
    .form-control {
      width: 100%; padding: 12px 14px;
      background: var(--color-bg-base);
      border: 1px solid var(--color-border);
      border-radius: 8px;
      color: var(--color-text-primary);
      font-size: 15px;
      transition: border-color 0.2s;
    }
    .form-control:focus { outline: none; border-color: var(--color-primary); }
    .input-group { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }

    .btn {
      width: 100%; padding: 12px 16px; border: none; border-radius: 8px; font-size: 14px;
      cursor: pointer; font-weight: 600; display: inline-flex;
      align-items: center; justify-content: center; gap: 8px;
      transition: all 0.2s;
    }
    .btn-primary { background: var(--color-primary); color: #0f172a; }
    .btn-primary:active { background: var(--color-primary-hover); transform: scale(0.98); }
    .btn-secondary { background: var(--color-bg-surface); color: var(--color-text-primary); }
    .btn-secondary:active { background: #475569; }
    .btn-danger { background: rgba(239, 68, 68, 0.15); color: #f87171; }
    
    .btn-group { display: flex; gap: 10px; }
    .btn-group .btn { flex: 1; }
    .btn:disabled { opacity: 0.5; pointer-events: none; }

    /* Toggle Switch */
    .toggle-row {
      display: flex; align-items: center; justify-content: space-between;
      margin-bottom: 14px; padding: 4px 0;
    }
    .toggle-row span { font-size: 14px; font-weight: 500; }
    
    .toggle-switch { display: flex; align-items: center; cursor: pointer; }
    .toggle-switch input { display: none; }
    .toggle-slider {
      width: 44px; height: 24px; background: var(--color-bg-surface);
      border-radius: 24px; position: relative;
      transition: 0.3s; border: 1px solid var(--color-border);
    }
    .toggle-slider::before {
      content: ""; position: absolute; width: 18px; height: 18px;
      border-radius: 50%; background: var(--color-text-secondary);
      top: 2px; left: 2px; transition: 0.3s;
    }
    .toggle-switch input:checked + .toggle-slider { background: var(--color-primary); border-color: var(--color-primary); }
    .toggle-switch input:checked + .toggle-slider::before { transform: translateX(20px); background: #0f172a; }

    /* Dpad Controls (Mới: Dàn hàng ngang) */
    .dpad-container {
      display: flex;
      flex-direction: row;
      gap: 8px;
      width: 100%;
      margin: 15px 0;
    }
    .dpad-btn {
      flex: 1;
      background: var(--color-bg-surface); border: none; border-radius: 8px;
      color: white; height: 45px; display: flex; align-items: center; justify-content: center;
      font-size: 18px;
    }
    .dpad-btn:active { background: var(--color-primary); color: #000; }

    /* Range Slider */
    input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%;
      background: var(--color-primary); margin-top: -8px;
    }
    input[type=range]::-webkit-slider-runnable-track {
      width: 100%; height: 4px; background: var(--color-bg-surface); border-radius: 2px;
    }
  </style>
</head>
<body>

  <!-- Nửa trên: Canvas & Tools -->
  <div class="canvas-container" id="canvasContainer">
    <canvas id="canvas"></canvas>
    <div id="zoom-indicator">Zoom: 100%</div>
    
    <!-- Floating Tools chuẩn Mobile -->
    <div class="floating-tools">
      <button class="tool-btn" id="floatDeleteBtn" disabled title="Xóa"><i class="fas fa-trash-alt"></i></button>
      <button class="tool-btn" id="floatCloneBtn" disabled title="Nhân bản (Copy)"><i class="fas fa-copy"></i></button>
      <button class="tool-btn" id="resetViewBtnMobile" title="Phóng vừa màn hình"><i class="fas fa-expand"></i></button>
      <button class="tool-btn" id="undoBtn" disabled title="Hoàn tác"><i class="fas fa-undo"></i></button>
      <button class="tool-btn" id="redoBtn" disabled title="Làm lại"><i class="fas fa-redo"></i></button>
    </div>
  </div>

  <!-- Nửa dưới: Điều khiển -->
  <div class="controls-area">
    
    <!-- Tabs Navigation (Đã xóa Tab Tạo Bộ) -->
    <div class="tabs-nav">
      <button class="tab-btn active" data-target="tab-tuong">
        <i class="fas fa-border-all"></i><span>Tường</span>
      </button>
      <button class="tab-btn" data-target="tab-tinhchinh">
        <i class="fas fa-sliders-h"></i><span>Tinh chỉnh</span>
      </button>
      <button class="tab-btn" data-target="tab-khac">
        <i class="fas fa-cog"></i><span>Khác</span>
      </button>
    </div>

    <!-- Nội dung Tabs -->
    <div class="panels-container">
      
      <!-- TAB 1: TƯỜNG -->
      <div id="tab-tuong" class="tab-content active">
        <div class="panel-card">
          <h2 class="section-title">1. Kích thước tường (cm)</h2>
          <div class="input-group">
            <div class="form-group">
              <label class="form-label">Ngang</label>
              <input type="number" class="form-control" id="wallWidth" value="300" min="50">
            </div>
            <div class="form-group">
              <label class="form-label">Cao</label>
              <input type="number" class="form-control" id="wallHeight" value="250" min="50">
            </div>
          </div>
          <button class="btn btn-primary" id="updateWallBtn"><i class="fas fa-check"></i> Cập nhật tường</button>
        </div>

        <div class="panel-card">
          <h2 class="section-title">2. Vật thể đối chứng (Sofa/Kệ)</h2>
          <div class="toggle-row">
            <span>Hiển thị vật thể</span>
            <label class="toggle-switch">
              <input type="checkbox" id="showFurniture" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
          <div class="input-group">
            <div class="form-group">
              <label class="form-label">Rộng (cm)</label>
              <input type="number" class="form-control" id="furnW" value="200">
            </div>
            <div class="form-group">
              <label class="form-label">Cao (cm)</label>
              <input type="number" class="form-control" id="furnH" value="80">
            </div>
          </div>
          <div class="form-group" style="margin-top: 10px;">
            <label class="form-label" style="color: var(--color-primary);">Khoảng cách từ vật thể đến tranh (cm)</label>
            <div style="display: flex; gap: 8px;">
              <input type="number" class="form-control" id="furnDist" value="20">
              <button class="btn btn-primary" id="alignFurnBtn" style="width: auto; white-space: nowrap;">Căn tự động</button>
            </div>
          </div>
        </div>
      </div>

      <!-- TAB 2: TINH CHỈNH -->
      <div id="tab-tinhchinh" class="tab-content">
        
        <!-- Quản lý hình ảnh -->
        <div class="panel-card">
          <h2 class="section-title"><i class="fas fa-image"></i> Hình ảnh hiển thị</h2>
          <input type="file" id="imageUpload" accept="image/*" style="display: none;">
          
          <div class="btn-group" style="margin-bottom: 16px;">
            <button class="btn btn-primary" id="uploadBtn"><i class="fas fa-upload"></i> Tải ảnh lên</button>
            <button class="btn btn-secondary" id="editImgBtn"><i class="fas fa-tools"></i> Chế độ chỉnh ảnh</button>
          </div>

          <div class="toggle-row" style="background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px;">
            <span style="color: var(--color-primary);">1 ảnh tràn nhiều khung</span>
            <label class="toggle-switch">
              <input type="checkbox" id="globalImgToggle">
              <span class="toggle-slider"></span>
            </label>
          </div>

          <div id="imgScaleGroup" style="opacity: 0.5; pointer-events: none; margin-top: 16px;">
            <div class="toggle-row" style="margin-bottom: 8px;">
              <span style="font-size: 12px; color: var(--color-text-secondary);">Zoom ảnh</span>
              <span id="imgScaleVal" style="font-size: 12px;">100%</span>
            </div>
            <input type="range" id="imgScaleSlider" min="0.1" max="5" step="0.05" value="1">
            <div style="margin-top: 16px;">
              <button class="btn btn-secondary" id="resetImgBtn" style="width: 100%">Reset vị trí ảnh</button>
            </div>
          </div>
        </div>

        <!-- Tinh chỉnh tranh được chọn -->
        <div class="panel-card" id="editPanel">
          <h2 class="section-title">Chi tiết khung tranh</h2>
          
          <div class="input-group">
            <div class="form-group">
              <label class="form-label">Ngang (cm)</label>
              <input type="number" class="form-control" id="picW">
            </div>
            <div class="form-group">
              <label class="form-label">Cao (cm)</label>
              <input type="number" class="form-control" id="picH">
            </div>
          </div>
          
          <div class="btn-group" style="margin-bottom: 16px;">
            <button class="btn btn-secondary" id="rotateBtn"><i class="fas fa-sync-alt"></i> Xoay khung tranh</button>
            <!-- Nút Kích thước chung mới -->
            <button class="btn btn-secondary" id="commonSizeBtn" disabled title="Chỉ bật khi trên tường có duy nhất 1 bức tranh">Kích thước chung</button>
          </div>

          <!-- Mũi tên Di chuyển dàn hàng ngang -->
          <div style="border-top: 1px solid var(--color-border); padding-top: 16px; margin-top: 16px;">
            <div class="form-group" style="display: flex; align-items: center; justify-content: space-between; gap: 10px;">
              <label class="form-label" style="margin:0; white-space: nowrap;">Bước di chuyển (cm):</label>
              <input type="number" class="form-control" id="moveStep" value="1" min="0.1" step="0.1" style="padding: 6px; text-align: center; width: 80px;">
            </div>
            <div class="dpad-container">
              <button class="dpad-btn" id="navLeft"><i class="fas fa-arrow-left"></i></button>
              <button class="dpad-btn" id="navUp"><i class="fas fa-arrow-up"></i></button>
              <button class="dpad-btn" id="navDown"><i class="fas fa-arrow-down"></i></button>
              <button class="dpad-btn" id="navRight"><i class="fas fa-arrow-right"></i></button>
            </div>
          </div>
        </div>

      </div>

      <!-- TAB 3: KHÁC (Tùy chọn & Xuất) -->
      <div id="tab-khac" class="tab-content">
        <div class="panel-card">
          <h2 class="section-title">Công cụ hiển thị</h2>
          
          <div class="toggle-row" style="background: rgba(56, 189, 248, 0.1); padding: 10px; border-radius: 8px; margin-bottom: 16px;">
            <span style="color: var(--color-primary);">Di chuyển cả bộ</span>
            <label class="toggle-switch">
              <input type="checkbox" id="moveAllGroup">
              <span class="toggle-slider"></span>
            </label>
          </div>

          <button class="btn btn-secondary" id="centerAllBtn" style="margin-bottom: 16px; width: 100%;">
            <i class="fas fa-align-center"></i> Tự động căn giữa toàn bộ
          </button>

          <div class="toggle-row">
            <span>Hiện thông số trong tranh</span>
            <label class="toggle-switch">
              <input type="checkbox" id="showDimensions" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
          <div class="toggle-row">
            <span>Hiện bảng thông tin tường</span>
            <label class="toggle-switch">
              <input type="checkbox" id="showWallInfo" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
          <div class="toggle-row">
            <span>Đường gióng thông minh (Smart Guide)</span>
            <label class="toggle-switch">
              <input type="checkbox" id="smartGuides" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
        </div>

        <div class="panel-card" style="margin-bottom: 30px;">
          <h2 class="section-title">Xuất file ảnh</h2>
          <div class="btn-group">
            <button class="btn btn-primary" id="exportJpegBtn">Lưu JPEG</button>
            <button class="btn btn-primary" id="exportPngBtn">Lưu PNG (Nền trong)</button>
          </div>
        </div>
      </div>

    </div>
  </div>

  <script>
    /** --- LOGIC TAB ĐIỀU KHIỂN --- **/
    const tabBtns = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.tab-content');

    tabBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        // Xóa active hiện tại
        tabBtns.forEach(b => b.classList.remove('active'));
        tabContents.forEach(c => c.classList.remove('active'));
        // Kích hoạt tab mới
        btn.classList.add('active');
        const targetId = btn.getAttribute('data-target');
        document.getElementById(targetId).classList.add('active');
      });
    });

    /** --- CORE STATE --- **/
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvasContainer');

    const app = { w: 300, h: 250, scale: 1, panX: 0, panY: 0 };
    let pictures = [];
    let selectedPic = null;
    let furniture = { w: 200, h: 80, visible: true, distance: 20 };

    // Image System State
    const imgCache = new Map(); 
    let isGlobalMaskMode = false;
    let globalImgData = null; 
    let isImgEditMode = false;
    let isDraggingImg = false;
    
    // Common Size Mode State
    let isCommonSizeMode = false;

    // Interaction State
    let isDragging = false; 
    let isPanning = false; 
    let dragStart = { x: 0, y: 0 };
    let panStart = { x: 0, y: 0 }; 
    let initialPositions = new Map(); 

    // Touch Pinch State (Trạng thái Zoom 2 ngón tay)
    let pinchStartDist = 0;
    let pinchStartScale = 1;
    let pinchStartCenter = { x: 0, y: 0 };
    let pinchStartPan = { x: 0, y: 0 };

    // View Options
    let showDimensions = true;
    let showWallInfo = true; 
    let enableSmartGuides = true;
    let moveAllGroup = false;
    let activeGuides = [];

    const history = { stack: [], current: -1, max: 20 }; 
    let zoomTimeout = null; 

    /* =========================================
       INITIALIZATION & EVENTS
       ========================================= */
    function init() {
        // Khởi tạo 1 tranh mặc định ban đầu để người dùng dễ dùng tính năng "Kích thước chung"
        createPics(1, 50, 70, 0);
        updateEditPanel(); 
        
        window.addEventListener('resize', () => {
             resizeCanvas();
             fitWallToScreen(); 
             drawLoop();
        });
        resizeCanvas();
        fitWallToScreen();
        
        // Touch/Mobile Events
        setupTouchEvents();
        
        // Desktop Events
        canvas.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
        canvas.addEventListener('wheel', onWheel, { passive: false });
        
        setupUIControls();
        requestAnimationFrame(drawLoop);
        saveState();
    }

    function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = container.clientWidth * dpr;
        canvas.height = container.clientHeight * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function fitWallToScreen() {
        const pad = 40; 
        const availableW = container.clientWidth - pad;
        const availableH = container.clientHeight - pad;
        
        const scaleW = availableW / app.w;
        const scaleH = availableH / app.h;
        app.scale = Math.min(scaleW, scaleH); 
        app.baseScale = app.scale; 
        
        const wallPixelW = app.w * app.scale;
        const wallPixelH = app.h * app.scale;
        
        app.panX = (container.clientWidth - wallPixelW) / 2;
        app.panY = (container.clientHeight - wallPixelH) / 2;
        
        showZoomLevel();
    }

    function getPinchDistance(touches) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function getPinchCenter(touches) {
        return {
            x: (touches[0].clientX + touches[1].clientX) / 2,
            y: (touches[0].clientY + touches[1].clientY) / 2
        };
    }

    function setupTouchEvents() {
        const getTouchPos = (e) => {
            const touch = e.touches[0] || e.changedTouches[0];
            return { clientX: touch.clientX, clientY: touch.clientY };
        };

        canvas.addEventListener('touchstart', (e) => {
            if(e.cancelable) e.preventDefault(); 
            
            if(e.touches.length === 1) {
                onMouseDown(getTouchPos(e));
            } else if (e.touches.length === 2) {
                pinchStartDist = getPinchDistance(e.touches);
                pinchStartScale = app.scale;
                
                const rect = canvas.getBoundingClientRect();
                const centerScreen = getPinchCenter(e.touches);
                pinchStartCenter = {
                    x: centerScreen.x - rect.left,
                    y: centerScreen.y - rect.top
                };
                pinchStartPan = { x: app.panX, y: app.panY };
                
                isDragging = false;
                isPanning = false;
                isDraggingImg = false;
            }
        }, {passive: false});

        canvas.addEventListener('touchmove', (e) => {
            if(e.cancelable) e.preventDefault(); 
            
            if(e.touches.length === 1 && pinchStartDist === 0) {
                onMouseMove(getTouchPos(e));
            } else if (e.touches.length === 2) {
                const currentDist = getPinchDistance(e.touches);
                const zoomFactor = currentDist / pinchStartDist;
                
                let newScale = pinchStartScale * zoomFactor;
                if (newScale < 0.1) newScale = 0.1;
                if (newScale > 10) newScale = 10;
                
                app.scale = newScale;

                const rect = canvas.getBoundingClientRect();
                const currentCenterScreen = getPinchCenter(e.touches);
                const currentCenterX = currentCenterScreen.x - rect.left;
                const currentCenterY = currentCenterScreen.y - rect.top;

                const worldX = (pinchStartCenter.x - pinchStartPan.x) / pinchStartScale;
                const worldY = (pinchStartCenter.y - pinchStartPan.y) / pinchStartScale;

                app.panX = currentCenterX - worldX * app.scale;
                app.panY = currentCenterY - worldY * app.scale;

                showZoomLevel();
            }
        }, {passive: false});

        canvas.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) {
                pinchStartDist = 0; 
                onMouseUp();
            } else if (e.touches.length === 1) {
                isDragging = false;
                isPanning = false;
                isDraggingImg = false;
            }
        });
    }

    function setupUIControls() {
        document.getElementById('resetViewBtnMobile').onclick = fitWallToScreen;

        const updateWall = () => { 
            let w = parseInt(document.getElementById('wallWidth').value);
            let h = parseInt(document.getElementById('wallHeight').value);
            app.w = isNaN(w) || w < 50 ? 300 : w; 
            app.h = isNaN(h) || h < 50 ? 250 : h;
            document.getElementById('wallWidth').value = app.w;
            document.getElementById('wallHeight').value = app.h;
            fitWallToScreen(); saveState();
        };
        document.getElementById('updateWallBtn').onclick = updateWall;

        const updateFurn = () => {
            let fw = parseFloat(document.getElementById('furnW').value);
            let fh = parseFloat(document.getElementById('furnH').value);
            let fd = parseFloat(document.getElementById('furnDist').value);
            
            furniture.w = isNaN(fw) || fw < 10 ? 200 : fw;
            furniture.h = isNaN(fh) || fh < 10 ? 80 : fh;
            furniture.distance = isNaN(fd) ? 20 : fd; 
            furniture.visible = document.getElementById('showFurniture').checked;
            
            document.getElementById('furnW').value = furniture.w;
            document.getElementById('furnH').value = furniture.h;
            document.getElementById('furnDist').value = furniture.distance;
            saveState();
        };
        ['furnW','furnH', 'showFurniture'].forEach(id => document.getElementById(id).addEventListener('change', updateFurn));
        document.getElementById('alignFurnBtn').onclick = () => { updateFurn(); alignArtToFurniture(); };

        document.getElementById('centerAllBtn').onclick = centerAllContent;

        document.getElementById('picW').onchange = updateSelectedSize;
        document.getElementById('picH').onchange = updateSelectedSize;

        // Xử lý nút Kích thước chung
        document.getElementById('commonSizeBtn').onclick = () => {
            if (pictures.length === 1) {
                isCommonSizeMode = !isCommonSizeMode;
                updateEditPanel();
            }
        };

        // Cấu hình Nút Nổi Copy trên Canvas
        document.getElementById('floatCloneBtn').onclick = () => {
            if (isCommonSizeMode && pictures.length === 1 && selectedPic) {
                // Đang trong chế độ "Kích thước chung"
                let countStr = prompt("Tạo bộ bao nhiêu tranh? (ví dụ: 3)", "3");
                if (countStr === null) return; // Người dùng bấm Hủy
                let count = parseInt(countStr);
                if (isNaN(count) || count <= 1) {
                    alert("Số lượng tranh phải lớn hơn 1.");
                    isCommonSizeMode = false; updateEditPanel(); return;
                }
                
                let gapStr = prompt("Khoảng cách giữa các tranh (cm):", "5");
                if (gapStr === null) return; // Người dùng bấm Hủy
                let gap = parseFloat(gapStr) || 0;

                let startX = selectedPic.x;
                let y = selectedPic.y;
                let w = selectedPic.w;
                let h = selectedPic.h;
                let maxZ = selectedPic.z || 0;

                // Tự động sinh ra các bức tranh tiếp theo dàn hàng ngang
                for (let i = 1; i < count; i++) {
                    const clone = {
                        id: Date.now() + i,
                        z: maxZ + i,
                        x: startX + i * (w + gap),
                        y: y,
                        w: w,
                        h: h,
                        locked: false,
                        imgData: null
                    };
                    pictures.push(clone);
                }
                
                // Sau khi tạo xong bộ thì tắt mode và căn giữa tự động
                isCommonSizeMode = false;
                centerAllContent();
                updateEditPanel();
                saveState();
            } else {
                // Nhận bản (Copy) bình thường 1 bức
                cloneSelectedPic();
            }
        };
        
        // Cấu hình Nút Nổi Delete trên Canvas
        document.getElementById('floatDeleteBtn').onclick = () => {
            if (isImgEditMode) {
                // Xóa ảnh
                if (isGlobalMaskMode) globalImgData = null;
                else if (selectedPic) selectedPic.imgData = null;
            } else {
                // Xóa tranh
                if (selectedPic && !selectedPic.locked) {
                    pictures = pictures.filter(p => p !== selectedPic); 
                    selectedPic = null; 
                    if(pictures.length === 0) isGlobalMaskMode = false; 
                }
            }
            updateEditPanel(); 
            saveState();
        };

        document.getElementById('rotateBtn').onclick = () => {
            if(!selectedPic) return;
            [selectedPic.w, selectedPic.h] = [selectedPic.h, selectedPic.w];
            updateEditPanel(); saveState();
        };

        const move = (dx, dy) => moveSelection(dx, dy);
        document.getElementById('navUp').onclick = () => move(0, -1);
        document.getElementById('navDown').onclick = () => move(0, 1);
        document.getElementById('navLeft').onclick = () => move(-1, 0);
        document.getElementById('navRight').onclick = () => move(1, 0);

        document.getElementById('showDimensions').onchange = (e) => showDimensions = e.target.checked;
        document.getElementById('showWallInfo').onchange = (e) => showWallInfo = e.target.checked;
        document.getElementById('smartGuides').onchange = (e) => enableSmartGuides = e.target.checked;
        document.getElementById('moveAllGroup').onchange = (e) => moveAllGroup = e.target.checked;

        document.getElementById('uploadBtn').onclick = () => {
            if (isGlobalMaskMode && pictures.length === 0) { alert('Cần ít nhất 1 bức tranh để tạo set!'); return; }
            if (!isGlobalMaskMode && !selectedPic) { alert('Vui lòng chọn 1 bức tranh trước!'); return; }
            document.getElementById('imageUpload').click();
        };

        document.getElementById('editImgBtn').onclick = () => {
            isImgEditMode = !isImgEditMode;
            updateEditPanel();
        };

        document.getElementById('globalImgToggle').onchange = (e) => {
            isGlobalMaskMode = e.target.checked;
            updateEditPanel(); saveState();
        };

        document.getElementById('imageUpload').onchange = handleFileUpload;

        const imgScaleSlider = document.getElementById('imgScaleSlider');
        imgScaleSlider.oninput = (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('imgScaleVal').innerText = Math.round(val * 100) + '%';
            if (isGlobalMaskMode && globalImgData) {
                globalImgData.scale = globalImgData.baseScale * val;
            } else if (selectedPic && selectedPic.imgData) {
                selectedPic.imgData.scale = selectedPic.imgData.baseScale * val;
            }
        };
        imgScaleSlider.onchange = () => saveState();

        document.getElementById('resetImgBtn').onclick = () => {
            if (isGlobalMaskMode && globalImgData) {
                globalImgData.offsetX = 0; globalImgData.offsetY = 0; globalImgData.scale = globalImgData.baseScale;
            } else if (selectedPic && selectedPic.imgData) {
                selectedPic.imgData.offsetX = 0; selectedPic.imgData.offsetY = 0; selectedPic.imgData.scale = selectedPic.imgData.baseScale;
            }
            updateEditPanel(); saveState();
        };

        document.getElementById('undoBtn').onclick = undo;
        document.getElementById('redoBtn').onclick = redo;
        document.getElementById('exportJpegBtn').onclick = () => downloadImage('jpeg');
        document.getElementById('exportPngBtn').onclick = () => downloadImage('png');
    }

    /* =========================================
       LOGIC XỬ LÝ ẢNH, CANVAS, XUẤT FILE 
       ========================================= */
    function handleFileUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(event) {
            const originalBase64 = event.target.result;
            const img = new Image();
            img.onload = function() {
                const MAX_SIZE = 1920; 
                let targetW = img.width, targetH = img.height;
                if (targetW > MAX_SIZE || targetH > MAX_SIZE) {
                    const ratio = Math.min(MAX_SIZE / targetW, MAX_SIZE / targetH);
                    targetW = Math.round(targetW * ratio); targetH = Math.round(targetH * ratio);
                }
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = targetW; tempCanvas.height = targetH;
                const tCtx = tempCanvas.getContext('2d');
                tCtx.drawImage(img, 0, 0, targetW, targetH);
                const isPng = file.type === 'image/png';
                const optimizedBase64 = tempCanvas.toDataURL(isPng ? 'image/png' : 'image/jpeg', isPng ? undefined : 0.8);
                const finalImg = new Image();
                finalImg.onload = function() {
                    imgCache.set(optimizedBase64, finalImg);
                    if (!isGlobalMaskMode && selectedPic) {
                        const baseScale = Math.max(selectedPic.w / finalImg.width, selectedPic.h / finalImg.height);
                        selectedPic.imgData = { base64: optimizedBase64, scale: baseScale, baseScale: baseScale, offsetX: 0, offsetY: 0 };
                    } else if (isGlobalMaskMode) {
                        pictures.forEach(p => p.imgData = null);
                        const bounds = getSetBounds();
                        const baseScale = Math.max((bounds.maxX - bounds.minX) / finalImg.width, (bounds.maxY - bounds.minY) / finalImg.height);
                        globalImgData = { base64: optimizedBase64, scale: baseScale, baseScale: baseScale, offsetX: 0, offsetY: 0 };
                    }
                    isImgEditMode = true; updateEditPanel(); saveState();
                };
                finalImg.src = optimizedBase64;
            };
            img.src = originalBase64;
        };
        reader.readAsDataURL(file);
        e.target.value = ''; 
    }

    function getSetBounds() {
        if(pictures.length === 0) return {minX:0, minY:0, maxX:0, maxY:0};
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        pictures.forEach(p => {
            if (p.x < minX) minX = p.x; if (p.y < minY) minY = p.y;
            if (p.x + p.w > maxX) maxX = p.x + p.w; if (p.y + p.h > maxY) maxY = p.y + p.h;
        });
        return {minX, minY, maxX, maxY};
    }

    function ensureImageLoaded(base64) {
        if (!base64) return null;
        if (imgCache.has(base64)) return imgCache.get(base64);
        const img = new Image(); img.src = base64; imgCache.set(base64, img);
        return img; 
    }

    function toWorld(screenX, screenY) {
        return { x: (screenX - app.panX) / app.scale, y: (screenY - app.panY) / app.scale };
    }

    function onWheel(e) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left, mouseY = e.clientY - rect.top;
        const delta = e.deltaY < 0 ? 1 : -1;
        const zoomIntensity = 0.1;
        const worldPos = toWorld(mouseX, mouseY);
        const newScale = app.scale * (1 + delta * zoomIntensity);
        if (newScale < 0.2 || newScale > 10) return;
        app.scale = newScale;
        app.panX = mouseX - worldPos.x * app.scale;
        app.panY = mouseY - worldPos.y * app.scale;
        showZoomLevel();
    }

    function showZoomLevel() {
        const el = document.getElementById('zoom-indicator');
        if (!el) return;
        const pct = app.baseScale ? Math.round((app.scale / app.baseScale) * 100) : Math.round(app.scale * 100);
        el.innerText = `Zoom: ${pct}%`;
        el.style.opacity = 1;
        clearTimeout(zoomTimeout);
        zoomTimeout = setTimeout(() => el.style.opacity = 0, 1500);
    }

    function onMouseDown(e) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left, mouseY = e.clientY - rect.top;
        const m = toWorld(mouseX, mouseY);
        let clicked = null;
        const hitList = pictures.map((p, i) => ({p, i})).sort((a, b) => ((b.p.z || 0) - (a.p.z || 0)) || (b.i - a.i)).map(x => x.p);

        for(let p of hitList) {
            if(m.x >= p.x && m.x <= p.x + p.w && m.y >= p.y && m.y <= p.y + p.h) { clicked = p; break; }
        }

        if (isImgEditMode) {
            if (clicked) {
                isDraggingImg = true; selectPicture(clicked); dragStart = { x: mouseX, y: mouseY }; 
            } else {
                isPanning = true; panStart = { x: mouseX, y: mouseY }; selectedPic = null; updateEditPanel();
            }
            return;
        }

        if(clicked) {
            selectPicture(clicked);
            if(!clicked.locked) {
                isDragging = true; dragStart = m; initialPositions.clear();
                pictures.forEach(p => initialPositions.set(p.id, { x: p.x, y: p.y }));
            }
        } else {
            isPanning = true; panStart = { x: mouseX, y: mouseY }; selectedPic = null; updateEditPanel();
        }
    }

    function onMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left, mouseY = e.clientY - rect.top;

        if (isPanning) {
            app.panX += (mouseX - panStart.x); app.panY += (mouseY - panStart.y);
            panStart = { x: mouseX, y: mouseY }; return;
        }

        if (isImgEditMode && isDraggingImg) {
            const dx = (mouseX - dragStart.x) / app.scale, dy = (mouseY - dragStart.y) / app.scale;
            if (isGlobalMaskMode && globalImgData) { globalImgData.offsetX += dx; globalImgData.offsetY += dy; } 
            else if (selectedPic && selectedPic.imgData) { selectedPic.imgData.offsetX += dx; selectedPic.imgData.offsetY += dy; }
            dragStart = { x: mouseX, y: mouseY }; return;
        }

        if (isDragging && selectedPic && !isImgEditMode) {
            const m = toWorld(mouseX, mouseY);
            const dx = m.x - dragStart.x, dy = m.y - dragStart.y;

            if (moveAllGroup) {
                pictures.forEach(p => { const init = initialPositions.get(p.id); if(init) { p.x = init.x + dx; p.y = init.y + dy; } });
                activeGuides = [];
            } else {
                const init = initialPositions.get(selectedPic.id); if(!init) return;
                let newX = init.x + dx, newY = init.y + dy;
                
                activeGuides = [];
                if(enableSmartGuides) {
                    const threshold = 10 / app.scale; 
                    const edgesX = [newX, newX + selectedPic.w/2, newX + selectedPic.w], edgesY = [newY, newY + selectedPic.h/2, newY + selectedPic.h];
                    const targetsX = [{val: app.w/2, type:'center'}], targetsY = [{val: app.h/2, type:'center'}];
                    
                    pictures.forEach(p => {
                        if(p === selectedPic) return;
                        targetsX.push({val: p.x, type:'edge'}, {val: p.x+p.w/2, type:'center'}, {val: p.x+p.w, type:'edge'});
                        targetsY.push({val: p.y, type:'edge'}, {val: p.y+p.h/2, type:'center'}, {val: p.y+p.h, type:'edge'});
                    });

                    let snappedX = false;
                    for(let edge of edgesX) {
                        for(let t of targetsX) {
                            if(Math.abs(edge - t.val) < threshold) { 
                                newX += t.val - edge; 
                                activeGuides.push({type:'v', x: t.val}); 
                                snappedX = true; 
                                break; 
                            }
                        }
                        if (snappedX) break; 
                    }

                    let snappedY = false;
                    for(let edge of edgesY) {
                        for(let t of targetsY) {
                            if(Math.abs(edge - t.val) < threshold) { 
                                newY += t.val - edge; 
                                activeGuides.push({type:'h', y: t.val}); 
                                snappedY = true; 
                                break; 
                            }
                        }
                        if (snappedY) break; 
                    }
                }
                selectedPic.x = newX; selectedPic.y = newY;
            }
        }
    }

    function onMouseUp() {
        if(isDragging) { isDragging = false; activeGuides = []; saveState(); }
        if(isPanning) { isPanning = false; }
        if(isDraggingImg) { isDraggingImg = false; saveState(); }
    }

    function drawImages(targetCtx, wallX, wallY, currentScale, renderList) {
        if (!renderList || renderList.length === 0) return;
        if (isGlobalMaskMode && globalImgData) {
            const img = ensureImageLoaded(globalImgData.base64);
            if (img && img.complete) {
                targetCtx.save(); targetCtx.beginPath();
                renderList.forEach(p => targetCtx.rect(wallX + p.x * currentScale, wallY + p.y * currentScale, p.w * currentScale, p.h * currentScale));
                targetCtx.clip();
                const bounds = getSetBounds();
                const setW = (bounds.maxX - bounds.minX) * currentScale, setH = (bounds.maxY - bounds.minY) * currentScale;
                const setCX = wallX + (bounds.minX * currentScale) + setW/2, setCY = wallY + (bounds.minY * currentScale) + setH/2;
                const imgW = img.width * globalImgData.scale * currentScale, imgH = img.height * globalImgData.scale * currentScale;
                targetCtx.drawImage(img, setCX - imgW/2 + (globalImgData.offsetX * currentScale), setCY - imgH/2 + (globalImgData.offsetY * currentScale), imgW, imgH);
                targetCtx.restore();
            }
        } else if (!isGlobalMaskMode) {
            renderList.forEach(p => {
                if (p.imgData) {
                    const img = ensureImageLoaded(p.imgData.base64);
                    if (img && img.complete) {
                        const px = wallX + p.x * currentScale, py = wallY + p.y * currentScale, pw = p.w * currentScale, ph = p.h * currentScale;
                        targetCtx.save(); targetCtx.beginPath(); targetCtx.rect(px, py, pw, ph); targetCtx.clip();
                        const imgW = img.width * p.imgData.scale * currentScale, imgH = img.height * p.imgData.scale * currentScale;
                        targetCtx.drawImage(img, px + pw/2 - imgW/2 + (p.imgData.offsetX * currentScale), py + ph/2 - imgH/2 + (p.imgData.offsetY * currentScale), imgW, imgH);
                        targetCtx.restore();
                    }
                }
            });
        }
    }

    function drawPictureOverlay(p, idx, targetCtx, wallX, wallY, currentScale) {
        const px = wallX + p.x * currentScale, py = wallY + p.y * currentScale, pw = p.w * currentScale, ph = p.h * currentScale;
        if(p === selectedPic) {
            targetCtx.strokeStyle = isImgEditMode ? '#f59e0b' : '#38bdf8'; 
            targetCtx.lineWidth = 3; targetCtx.strokeRect(px, py, pw, ph);
        }
        if(showDimensions) {
            const hasImg = isGlobalMaskMode && globalImgData || !isGlobalMaskMode && p.imgData;
            targetCtx.fillStyle = hasImg ? 'rgba(255,255,255,0.8)' : '#000000'; 
            targetCtx.shadowColor = 'transparent'; targetCtx.shadowBlur = 0;
            const fontSize = Math.max(12, 5 * currentScale);
            targetCtx.font = `bold ${fontSize}px sans-serif`;
            targetCtx.textAlign = 'center'; targetCtx.textBaseline = 'middle';
            targetCtx.fillText(String(idx + 1).padStart(2, '0'), px + pw/2, py + ph/2 - fontSize/1.2);
            targetCtx.font = `${fontSize * 0.8}px sans-serif`;
            targetCtx.fillText(`${Math.round(p.w)}x${Math.round(p.h)}cm`, px + pw/2, py + ph/2 + fontSize/1.2);
        }
    }

    function drawLoop() {
        ctx.clearRect(0, 0, container.clientWidth, container.clientHeight);
        
        // Vẽ Grid
        const spacing = 50 * app.scale; 
        const offsetX = app.panX % spacing, offsetY = app.panY % spacing;
        ctx.beginPath();
        for (let x = offsetX; x < container.clientWidth; x += spacing) { ctx.moveTo(x, 0); ctx.lineTo(x, container.clientHeight); }
        for (let y = offsetY; y < container.clientHeight; y += spacing) { ctx.moveTo(0, y); ctx.lineTo(container.clientWidth, y); }
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)'; ctx.lineWidth = 1; ctx.stroke();

        const wallX = app.panX, wallY = app.panY, wallW = app.w * app.scale, wallH = app.h * app.scale;

        ctx.shadowColor = 'rgba(0,0,0,0.3)'; ctx.shadowBlur = 15; ctx.shadowOffsetY = 5;
        ctx.fillStyle = '#e2e8f0'; ctx.fillRect(wallX, wallY, wallW, wallH);
        ctx.shadowColor = 'transparent'; ctx.strokeStyle = '#cbd5e1'; ctx.lineWidth = 2; ctx.strokeRect(wallX, wallY, wallW, wallH);

        if (furniture.visible) {
            const fW = furniture.w * app.scale, fH = furniture.h * app.scale;
            const fX = wallX + (wallW - fW) / 2, fY = wallY + wallH - fH;
            ctx.fillStyle = '#8b8e95'; ctx.fillRect(fX, fY, fW, fH);
            ctx.fillStyle = '#000000'; ctx.font = `bold ${Math.max(12, 5 * app.scale)}px sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
            ctx.fillText(`Vật thể ${furniture.w}x${furniture.h}cm`, fX + fW/2, fY - (2 * app.scale));
        }

        const renderList = pictures.map((p, i) => ({p, i})).sort((a, b) => ((a.p.z || 0) - (b.p.z || 0)) || (a.i - b.i)).map(x => x.p);
        renderList.forEach((p) => { ctx.fillStyle = '#c4ced0'; ctx.fillRect(wallX + p.x * app.scale, wallY + p.y * app.scale, p.w * app.scale, p.h * app.scale); });

        drawImages(ctx, wallX, wallY, app.scale, renderList);

        renderList.forEach((p) => { if (p !== selectedPic) drawPictureOverlay(p, pictures.indexOf(p), ctx, wallX, wallY, app.scale); });
        if (selectedPic) drawPictureOverlay(selectedPic, pictures.indexOf(selectedPic), ctx, wallX, wallY, app.scale);

        ctx.beginPath();
        activeGuides.forEach(g => {
            if(g.type === 'v') { const gx = wallX + g.x * app.scale; ctx.moveTo(gx, 0); ctx.lineTo(gx, container.clientHeight); } 
            else { const gy = wallY + g.y * app.scale; ctx.moveTo(0, gy); ctx.lineTo(container.clientWidth, gy); }
        });
        ctx.strokeStyle = '#ec4899'; ctx.lineWidth = 1; ctx.setLineDash([4, 4]); ctx.stroke(); ctx.setLineDash([]);
        
        drawWallInfoBox(ctx, wallX, wallY, wallW, wallH, app.scale);
        requestAnimationFrame(drawLoop);
    }

    function calculateGapInfo() {
        if (pictures.length < 2) return "--";
        let gaps = []; const sorted = [...pictures].sort((a,b) => a.x - b.x);
        for(let i=0; i<sorted.length; i++) {
            const p1 = sorted[i]; let minGap = Infinity; let found = false;
            for(let j=0; j<sorted.length; j++) {
                if(i === j) continue; const p2 = sorted[j];
                if (p2.x > p1.x) {
                    const top = Math.max(p1.y, p2.y), bottom = Math.min(p1.y + p1.h, p2.y + p2.h);
                    if (bottom > top) { 
                        const gap = p2.x - (p1.x + p1.w);
                        if (gap >= -0.5 && gap < minGap) { minGap = gap; found = true; }
                    }
                }
            }
            if(found && minGap < app.w) gaps.push(minGap);
        }
        if (gaps.length === 0) return "--";
        const avg = gaps.reduce((a,b)=>a+b,0)/gaps.length, min = Math.min(...gaps), max = Math.max(...gaps);
        if (max - min < 1) return Math.round(avg) + " cm"; return `${Math.round(min)} - ${Math.round(max)} cm`;
    }

    function drawWallInfoBox(targetCtx, wX, wY, wW, wH, currentScale) {
        if (!showWallInfo || pictures.length === 0) return;
        const bounds = getSetBounds(), setW = Math.round(bounds.maxX - bounds.minX), setH = Math.round(bounds.maxY - bounds.minY);
        let sizeMap = {}; pictures.forEach(p => { let key = `${Math.round(p.w)}x${Math.round(p.h)}`; sizeMap[key] = (sizeMap[key] || 0) + 1; });
        let sizeStrings = []; for (let key in sizeMap) sizeStrings.push(`${sizeMap[key]} bức ${key}cm`);
        let furnDistText = furniture.visible ? `${Math.round((app.h - furniture.h) - bounds.maxY)} cm` : "--";

        const lines = [
            { text: `THÔNG SỐ LAYOUT`, bold: true }, { text: `• Tường: ${app.w} x ${app.h} cm` }, { text: `• Set: ${setW} x ${setH} cm` },
            { text: `• SL: ${pictures.length} bức (${sizeStrings.join(", ")})` }, { text: `• Cách nhau: ${calculateGapInfo()}` }, { text: `• Cách vật thể: ${furnDistText}` }
        ];

        const fontSizePx = Math.max(10, 4 * currentScale), padding = fontSizePx * 0.8, lineHeight = fontSizePx * 1.5;
        targetCtx.font = `${fontSizePx}px sans-serif`;
        let maxW = 0; lines.forEach(l => { targetCtx.font = (l.bold ? `bold ` : `normal `) + `${fontSizePx}px sans-serif`; maxW = Math.max(maxW, targetCtx.measureText(l.text).width); });
        const boxW = maxW + padding * 2, boxH = lines.length * lineHeight + padding * 1.5, margin = 2 * currentScale;
        const boxX = wX + margin, boxY = wY + wH - boxH - margin;

        targetCtx.fillStyle = 'rgba(15, 23, 42, 0.85)'; targetCtx.beginPath();
        if (targetCtx.roundRect) targetCtx.roundRect(boxX, boxY, boxW, boxH, Math.max(4, 2 * currentScale)); else targetCtx.rect(boxX, boxY, boxW, boxH);
        targetCtx.fill();
        targetCtx.fillStyle = '#f1f5f9'; targetCtx.textBaseline = 'top'; targetCtx.textAlign = 'left';
        
        let currentY = boxY + padding;
        lines.forEach((l, i) => {
            targetCtx.font = (l.bold ? `bold ` : `normal `) + `${fontSizePx}px sans-serif`;
            targetCtx.fillText(l.text, boxX + padding, currentY); currentY += lineHeight; if(i === 0) currentY += padding/2; 
        });
    }

    function createPics(num, w, h, gap) {
        const cols = Math.floor((app.w - gap) / (w + gap)) || 1;
        const startX = (app.w - (Math.min(num, cols)*w + (Math.min(num, cols)-1)*gap))/2;
        const rows = Math.ceil(num/cols);
        const startY = (app.h - (rows*h + (rows-1)*gap))/2;
        pictures = [];
        for(let i=0; i<num; i++) pictures.push({ id: Date.now()+i, z: i, x: startX + (i%cols)*(w+gap), y: startY + Math.floor(i/cols)*(h+gap), w: w, h: h, locked: false, imgData: null });
        updateEditPanel();
    }

    function moveSelection(dx, dy) {
        if (!selectedPic || selectedPic.locked) return;
        let step = parseFloat(document.getElementById('moveStep').value) || 1;
        selectedPic.x += dx * step; selectedPic.y += dy * step;
        if(moveAllGroup) pictures.forEach(p => { if(p!==selectedPic) { p.x += dx*step; p.y += dy*step; }});
        saveState();
    }

    function updateSelectedSize() {
        if(selectedPic) {
            let w = parseInt(document.getElementById('picW').value) || selectedPic.w;
            let h = parseInt(document.getElementById('picH').value) || selectedPic.h;
            selectedPic.w = w; selectedPic.h = h;
            document.getElementById('picW').value = w; document.getElementById('picH').value = h;
            saveState();
        }
    }

    function cloneSelectedPic() {
        if(!selectedPic) return;
        let maxZ = pictures.reduce((max, p) => Math.max(max, p.z || 0), 0);
        const clone = { ...selectedPic, id: Date.now(), z: maxZ + 1, x: Math.min(app.w - selectedPic.w, selectedPic.x + 10), y: Math.min(app.h - selectedPic.h, selectedPic.y + 10), imgData: null };
        pictures.push(clone); selectPicture(clone); saveState();
    }

    function selectPicture(pic) {
        selectedPic = pic;
        if (pic) {
            let maxZ = pictures.reduce((max, p) => Math.max(max, p.z || 0), 0);
            if ((pic.z || 0) < maxZ) pic.z = maxZ + 1; 
        }
        updateEditPanel(); saveState();
    }
    
    function centerViewOnPic(pic) {
        app.panX = (container.clientWidth / 2) - ((pic.x + pic.w / 2) * app.scale);
        app.panY = (container.clientHeight / 2) - ((pic.y + pic.h / 2) * app.scale);
    }

    function updateEditPanel() {
        const panel = document.getElementById('editPanel');
        
        // Cập nhật trạng thái các nút nổi
        const floatCloneBtn = document.getElementById('floatCloneBtn');
        const floatDeleteBtn = document.getElementById('floatDeleteBtn');
        const commonSizeBtn = document.getElementById('commonSizeBtn');

        // Logic ẩn/hiện nút "Kích thước chung"
        if (pictures.length === 1) {
            commonSizeBtn.disabled = false;
        } else {
            commonSizeBtn.disabled = true;
            isCommonSizeMode = false; // Tự động tắt mode nếu không đủ điều kiện
        }
        
        // Đổi màu nút Kích thước chung khi đang kích hoạt
        if (isCommonSizeMode) {
            commonSizeBtn.classList.add('btn-primary');
            commonSizeBtn.classList.remove('btn-secondary');
        } else {
            commonSizeBtn.classList.add('btn-secondary');
            commonSizeBtn.classList.remove('btn-primary');
        }

        if(selectedPic) {
            panel.style.opacity = '1'; panel.style.pointerEvents = 'auto';
            document.getElementById('picW').value = Math.round(selectedPic.w); 
            document.getElementById('picH').value = Math.round(selectedPic.h);
            
            floatCloneBtn.disabled = false;
            floatDeleteBtn.disabled = false;
            
            // Đổi màu nút Clone nếu đang trong mode "Kích thước chung" để người dùng dễ nhận biết
            if (isCommonSizeMode) {
                floatCloneBtn.style.color = 'var(--color-primary)';
                floatCloneBtn.style.borderColor = 'var(--color-primary)';
            } else {
                floatCloneBtn.style.color = 'var(--color-text-primary)';
                floatCloneBtn.style.borderColor = 'rgba(255,255,255,0.1)';
            }

        } else {
            panel.style.opacity = '0.5'; panel.style.pointerEvents = 'none';
            document.getElementById('picW').value = ''; 
            document.getElementById('picH').value = '';

            floatCloneBtn.disabled = true;
            floatCloneBtn.style.color = 'var(--color-text-primary)';
            floatCloneBtn.style.borderColor = 'rgba(255,255,255,0.1)';
            
            // Xóa ảnh nền global mask vẫn được phép nếu không chọn tranh nào
            if (isImgEditMode && isGlobalMaskMode && globalImgData) {
                floatDeleteBtn.disabled = false;
            } else {
                floatDeleteBtn.disabled = true;
            }
        }

        document.getElementById('globalImgToggle').checked = isGlobalMaskMode;
        document.getElementById('editImgBtn').classList.toggle('btn-primary', isImgEditMode);
        document.getElementById('editImgBtn').classList.toggle('btn-secondary', !isImgEditMode);
        
        const imgScaleGroup = document.getElementById('imgScaleGroup');
        if (isImgEditMode && (isGlobalMaskMode || (selectedPic && selectedPic.imgData))) {
            imgScaleGroup.style.opacity = '1'; imgScaleGroup.style.pointerEvents = 'auto';
            let data = isGlobalMaskMode ? globalImgData : selectedPic.imgData;
            if(data) { document.getElementById('imgScaleSlider').value = data.scale / data.baseScale; document.getElementById('imgScaleVal').innerText = Math.round((data.scale / data.baseScale) * 100) + '%'; }
        } else {
            imgScaleGroup.style.opacity = '0.5'; imgScaleGroup.style.pointerEvents = 'none';
        }
    }

    function centerAllContent() {
        if(!pictures.length) return;
        let bounds = getSetBounds();
        const shiftX = (app.w - (bounds.maxX-bounds.minX))/2 - bounds.minX, shiftY = (app.h - (bounds.maxY-bounds.minY))/2 - bounds.minY;
        pictures.forEach(p=>{ p.x+=shiftX; p.y+=shiftY; }); saveState();
    }

    function alignArtToFurniture() {
        if(!pictures.length || !furniture.visible) return;
        let lowestY = -Infinity; pictures.forEach(p => { if ((p.y + p.h) > lowestY) lowestY = p.y + p.h; });
        const shiftY = ((app.h - furniture.h) - furniture.distance) - lowestY;
        pictures.forEach(p => p.y += shiftY); saveState();
    }

    function saveState() {
        const state = JSON.stringify({ pictures, furniture, w: app.w, h: app.h, isGlobalMaskMode, globalImgData });
        if(history.current < history.stack.length-1) history.stack = history.stack.slice(0, history.current+1);
        history.stack.push(state);
        if(history.stack.length>history.max) history.stack.shift(); else history.current++;
        updateUndoBtns();
    }
    function undo() { if(history.current>0) restoreState(history.stack[--history.current]); updateUndoBtns(); }
    function redo() { if(history.current<history.stack.length-1) restoreState(history.stack[++history.current]); updateUndoBtns(); }
    function restoreState(json) {
        const s = JSON.parse(json);
        app.w=s.w; app.h=s.h; pictures=s.pictures; furniture=s.furniture; 
        isGlobalMaskMode = s.isGlobalMaskMode || false; globalImgData = s.globalImgData || null;
        document.getElementById('wallWidth').value=app.w; document.getElementById('wallHeight').value=app.h;
        document.getElementById('furnW').value=furniture.w; document.getElementById('furnH').value=furniture.h;
        document.getElementById('furnDist').value=furniture.distance; document.getElementById('showFurniture').checked=furniture.visible;
        selectedPic=null; updateEditPanel();
    }
    function updateUndoBtns() { 
        document.getElementById('undoBtn').disabled = history.current <= 0; 
        document.getElementById('redoBtn').disabled = history.current >= history.stack.length - 1; 
    }

    function downloadImage(type) {
        const tCanvas = document.createElement('canvas'); const tCtx = tCanvas.getContext('2d');
        const scale = 15; tCanvas.width = app.w * scale; tCanvas.height = app.h * scale;
        
        tCtx.fillStyle = '#e2e8f0'; tCtx.fillRect(0,0,tCanvas.width, tCanvas.height);
        tCtx.strokeStyle = '#cbd5e1'; tCtx.lineWidth = scale * 0.2; tCtx.strokeRect(0,0,tCanvas.width, tCanvas.height);

        if(furniture.visible) {
            const fW = furniture.w*scale, fH = furniture.h*scale;
            tCtx.fillStyle='#8b8e95'; tCtx.fillRect((tCanvas.width-fW)/2, tCanvas.height-fH, fW, fH);
            tCtx.fillStyle = '#000000'; tCtx.font = `bold ${5 * scale}px sans-serif`; 
            tCtx.textAlign = 'center'; tCtx.textBaseline = 'bottom';
            tCtx.fillText(`Vật thể ${furniture.w}x${furniture.h}cm`, (tCanvas.width)/2, tCanvas.height - fH - (2 * scale));
        }

        const renderList = pictures.map((p, i) => ({p, i})).sort((a, b) => ((a.p.z || 0) - (b.p.z || 0)) || (a.i - b.i)).map(x => x.p);

        if (type === 'jpeg') renderList.forEach(p => { tCtx.fillStyle='#c4ced0'; tCtx.fillRect(p.x*scale, p.y*scale, p.w*scale, p.h*scale); });
        else if (type === 'png') renderList.forEach(p => tCtx.clearRect(p.x*scale, p.y*scale, p.w*scale, p.h*scale));

        drawImages(tCtx, 0, 0, scale, renderList);
        
        renderList.forEach((p) => {
            const idx = pictures.indexOf(p), x=p.x*scale, y=p.y*scale, w=p.w*scale, h=p.h*scale;
            const hasImg = isGlobalMaskMode && globalImgData || !isGlobalMaskMode && p.imgData;
            if(showDimensions) {
                tCtx.fillStyle = hasImg ? 'rgba(255,255,255,0.8)' : '#000000'; 
                tCtx.shadowColor = 'transparent'; tCtx.shadowBlur = 0; 
                tCtx.font=`bold ${5 * scale}px sans-serif`; tCtx.textAlign='center'; tCtx.textBaseline='middle'; 
                tCtx.fillText(String(idx + 1).padStart(2, '0'), x+w/2, y+h/2 - (5*scale)/1.2);
                tCtx.font=`${(5*scale)*0.8}px sans-serif`; tCtx.fillText(`${Math.round(p.w)}x${Math.round(p.h)}cm`, x+w/2, y+h/2 + (5*scale)/1.2);
            }
        });

        drawWallInfoBox(tCtx, 0, 0, tCanvas.width, tCanvas.height, scale);
        const link = document.createElement('a'); link.download = `layout-${app.w}x${app.h}.${type}`;
        link.href = tCanvas.toDataURL(`image/${type}`); link.click();
    }

    init();
  </script>
</body>
</html>
